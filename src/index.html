<!DOCTYPE html>
<html lang="ko-KR">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Break Out</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=">
  <style>
    html, body {
      margin: 0;
      padding: 0;
    }
    canvas {
      display: block;
      margin: 30px auto 0;
      background-color: #f8f8f8;
      border: 1px solid #e0e0e0;
    }
    .control-group {
      margin-top: 20px;
      text-align: center;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="600px" height="450px"></canvas>

  <div class="control-group">
    <button type="button" id="btnControl" data-action="start">START</button>
    <button type="button" data-action="reload">RELOAD</button>
  </div>

  <ul>
    <li><del>공 그리기</del></li>
    <li><del>공 이동</del></li>
    <li><del>Paddle 그리기</del></li>
    <li><del>Paddle 키보드&amp;마우스 이동</del></li>
    <li><del>벽돌 그리기</del></li>
    <li><strong><del>벽돌 충돌감지&amp;제거(어려움)</del></strong></li>
    <li><del>GameOver&amp;Score&amp;Lives</del></li>
    <li><del>Timer</del></li>
    <li>공 모션</li>
  </ul>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    class BreakOut {
      start = false;
      ballRadian = 8;
      x = Math.floor(Math.random() * (canvas.width - this.ballRadian)) + this.ballRadian;
      y = canvas.height - this.ballRadian - 2;
      dx = 6;
      dy = -6;
      paddleWidth = 90;
      paddleHeight = 5;
      paddleLeft = false;
      paddleRight = false;
      paddleX = (canvas.width - this.paddleWidth) / 2;
      paddleCount = 7;
      bricks = [];
      brickWidth = 70;
      brickHeight = 25;
      brickPadding = 10;
      brickOffsetTop = 50;
      brickOffsetLeft = 25;
      brickColCount = 5;
      brickRowCount = 7;
      score = 0;
      lives = 1;
      startTime = Date.now();
      min = 0;
      sec = 0;
      milisec = 0;
      anim;

      constructor() {
        for (let i = 0; i < this.brickRowCount; i++) {
          this.bricks[i] = [];
          for (let k = 0; k < this.brickColCount; k++) {
            this.bricks[i][k] = {x: 0, y: 0, status: 1};
          }
        }
      }

      keyDownHandler(e) {
        if (e.which == 37) {
          breakOut.paddleLeft = true;
        } else if (e.which == 39) {
          breakOut.paddleRight = true;
        } else if (e.which == 107 || e.which == 43) {
          if (breakOut.paddleWidth < canvas.width) breakOut.paddleWidth += 100;
          // console.log(breakOut.paddleWidth);
        }
      }
      keyUpHandler(e) {
        if (e.which == 37) {
          breakOut.paddleLeft = false;
        } else if (e.which == 39) {
          breakOut.paddleRight = false;
        }
      }
      drawIntro(ctx) {
        ctx.font = '50px malgun gothic';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#000';
        ctx.fillText('Break Out', canvas.width / 2, canvas.height / 2 - 20);
        ctx.font = '25px malgun gothic';
        ctx.fillText('아래 [START] 버튼을 클릭해주세요!', canvas.width / 2, canvas.height / 2 + 20);
      }
      drawBricks() {
        for (let i = 0; i < breakOut.brickRowCount; i++) {
          for (let k = 0; k < breakOut.brickColCount; k++) {
            if (breakOut.bricks[i][k].status === 1) { // status 가 1일 경우에만 벽돌 그리기
              let brickX = (i * (breakOut.brickWidth + breakOut.brickPadding)) + breakOut.brickOffsetLeft;
              let brickY = (k * (breakOut.brickHeight + breakOut.brickPadding)) + breakOut.brickOffsetTop;

              breakOut.bricks[i][k].x = brickX;
              breakOut.bricks[i][k].y = brickY;

              ctx.beginPath();
              ctx.rect(brickX, brickY, breakOut.brickWidth, breakOut.brickHeight);
              ctx.fillStyle = '#e0e0e0';
              ctx.fill();
            }
          }
        }
      }
      drawBall(ctx) {
        ctx.beginPath();
        ctx.fillStyle = '#9c9c9c';
        ctx.arc(breakOut.x, breakOut.y, breakOut.ballRadian, 0, Math.PI * 2);
        ctx.fill();
      }
      drawPaddle() {
        ctx.beginPath();
        ctx.fillStyle = '#c5c5c5';
        ctx.fillRect(breakOut.paddleX, canvas.height - breakOut.paddleHeight, breakOut.paddleWidth, breakOut.paddleHeight);
        ctx.fill();
      }
      draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        breakOut.drawBall(ctx);
        breakOut.drawPaddle(ctx);
        breakOut.drawBricks(ctx);
        breakOut.drawScore();
        breakOut.drawLives();
        breakOut.drawEnd();

        const nowTime = new Date(Date.now() - breakOut.startTime);

        breakOut.min = breakOut.timeAddZero(nowTime.getMinutes());
        breakOut.sec = breakOut.timeAddZero(nowTime.getSeconds());
        breakOut.milisec = breakOut.timeAddZero(Math.floor(nowTime.getMilliseconds() / 10));
        // console.log(breakOut.min, breakOut.sec, breakOut.milisec);

        /*
          충동감지 어렵다.
          공의 x 좌표는 벽돌의 x 좌표보다 커야 한다.
          공의 x 좌표는 벽돌의 x 좌표 + 가로 길이보다 작아야 한다.
          공의 y 좌표는 벽돌의 y 좌표보다 커야 한다.
          공의 y 좌표는 벽돌의 y 좌표 + 높이보다 작아야 한다.
        */
        for (let i = 0; i < breakOut.brickRowCount; i++) {
          for (let k = 0; k < breakOut.brickColCount; k++) {
            let brickCurrent = breakOut.bricks[i][k];

            if (brickCurrent.status === 1) {
              if (breakOut.x > brickCurrent.x - breakOut.ballRadian && breakOut.x < brickCurrent.x + breakOut.brickWidth + breakOut.ballRadian && breakOut.y > brickCurrent.y - breakOut.ballRadian && breakOut.y < brickCurrent.y + breakOut.brickHeight + breakOut.ballRadian) {
                breakOut.dy = -breakOut.dy;
                brickCurrent.status = 0;
                breakOut.score += 100;
                // console.log('brickCurrntX,Y:', brickCurrent.x, brickCurrent.y, breakOut.score);
                if (breakOut.score === (breakOut.brickColCount * breakOut.brickRowCount) * 100) {
                  breakOut.start = true;
                  ctx.clearRect(0, 0, canvas.width, canvas.height);
                  ctx.font = '45px malgun gothic';
                  ctx.textAlign = 'center';
                  ctx.fillStyle = '#000';
                  ctx.fillText('Final Time!', canvas.width / 2, canvas.height / 2 - 20);
                  ctx.font = '25px malgun gothic';
                  ctx.fillText(`${breakOut.min}:${breakOut.sec}:${breakOut.milisec}`, canvas.width / 2, canvas.height / 2 + 20);
                  breakOut.gameStart();
                  return false;
                }
              }
            }
          }
        }

        if (breakOut.x > canvas.width - breakOut.ballRadian || breakOut.x < breakOut.ballRadian) { // Ball 좌우
          breakOut.dx = -breakOut.dx;
          // console.log('X 충돌!');
        }

        if (breakOut.y < breakOut.ballRadian) { // Ball 상하
          breakOut.dy = -breakOut.dy;
          // console.log('Y 충돌!');
        } else if (breakOut.y > canvas.height - breakOut.paddleHeight) {
          // console.log('paddle&ball 좌표:', breakOut.x, breakOut.paddleX + breakOut.paddleWidth);
          if (breakOut.x > breakOut.paddleX && breakOut.x < breakOut.paddleX + breakOut.paddleWidth) {
            // console.log('야호!');
            breakOut.dy = -breakOut.dy;
          } else {
            breakOut.lives--;
            if (!breakOut.lives) {
              // console.log('GAME OVER!');
              breakOut.gameOver();
              return false;
            } else {
              breakOut.x = canvas.width / 2;
              breakOut.y = canvas.height - breakOut.ballRadian;
              breakOut.dx = 6;
              breakOut.dy = -6;
              breakOut.paddleX = (canvas.width - breakOut.paddleWidth) / 2;
            }
          }
        }

        if (breakOut.paddleRight) { // Paddle Keyboard
          breakOut.paddleX += breakOut.paddleCount;
          if (breakOut.paddleX > canvas.width - breakOut.paddleWidth) {
            // console.log(canvas.width - breakOut.paddleWidth);
            breakOut.paddleX = canvas.width - breakOut.paddleWidth;
          }
        } else if (breakOut.paddleLeft) {
          breakOut.paddleX -= breakOut.paddleCount;
          if (breakOut.paddleX < 0) {
            breakOut.paddleX = 0;
          }
        }

        breakOut.x += breakOut.dx;
        breakOut.y += breakOut.dy;
        // console.log(breakOut.x, breakOut.y);

        breakOut.anim = window.requestAnimationFrame(breakOut.draw);
      }
      mouseMoveHandler(e) {
        const relativeX = e.clientX - canvas.offsetLeft;

        if (relativeX >= 0 && relativeX <= canvas.width) {
          breakOut.paddleX = relativeX - breakOut.paddleWidth / 2;
          // 마우스 커서가 캔버스 밖으로 넘어갔을 경우 (paddle 넓이 전체 보여주기)
          // if (relativeX < breakOut.paddleWidth / 2) {
          //   breakOut.paddleX = 0;
          // } else if (relativeX > canvas.width - breakOut.paddleWidth / 2) {
          //   breakOut.paddleX = canvas.width - breakOut.paddleWidth;
          // }
        }
      }
      drawScore() {
        ctx.font = '20px malgun gothic';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#000';
        ctx.fillText(`Score : ${breakOut.score}`, breakOut.brickOffsetLeft, 30);
      }
      drawLives() {
        ctx.font = '20px malgun gothic';
        ctx.textAlign = 'right';
        ctx.fillStyle = '#000';
        ctx.fillText(`Lives : ${breakOut.lives}`, canvas.width - breakOut.brickOffsetLeft, 30);
      }
      drawEnd() {
        ctx.font = '20px malgun gothic';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#000';
        ctx.fillText(`Time : ${breakOut.min}:${breakOut.sec}:${breakOut.milisec}`, canvas.width / 2, 30);
      }
      timeAddZero(num) {
        return (num < 10 ? '0'+num : ''+num);
      }
      gameStart() {
        if (!breakOut.start) {
          breakOut.start = false;
          window.cancelAnimationFrame(breakOut.anim);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          breakOut = new BreakOut();
          breakOut.draw(ctx);
        }
      }
      gameOver() {
        breakOut.start = true;
        window.cancelAnimationFrame(breakOut.anim);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = '50px malgun gothic';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#000';
        ctx.fillText('실력이 부족하구만~', canvas.width / 2, canvas.height / 2);
        breakOut.gameStart();
      }
      reload() {
        document.location.reload();
      }
    }

    let breakOut = new BreakOut();
    breakOut.drawIntro(ctx);

    document.addEventListener('keydown', breakOut.keyDownHandler, false);
    document.addEventListener('keyup', breakOut.keyUpHandler, false);
    document.addEventListener('mousemove', breakOut.mouseMoveHandler, false);
    document.addEventListener('click', e => {
      const { target } = e;
      const actionName = !!target.dataset && target.dataset.action;

      if (actionName === 'reload') {
        breakOut.reload();
      } else if (actionName === 'start') {
        breakOut.start = false;
        breakOut.gameStart();
      }
    });
  </script>
</body>
</html>
